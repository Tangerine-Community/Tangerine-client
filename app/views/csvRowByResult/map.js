// Generated by CoffeeScript 1.7.1
(function(doc) {
  var bySubtest, clone, datetimeCount, datetimeSuffix, doublesIncluded, exportValue, i, item, keyId, label, linearOrder, monthData, months, newData, observationData, observations, optionKey, optionValue, orderMap, pair, prototype, rawIndex, row, subtest, subtestData, subtestIds, subtestIndex, surveyValue, surveyVariable, timestamps, universal, utils, variableName, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _results;
  if (doc.collection !== "result") {
    return;
  }
  utils = require("views/lib/utils");
  clone = function (item) { if (!item) { return item; } var types = [ Number, String, Boolean ], result; types.forEach(function(type) { if (item instanceof type) { result = type( item ); } }); if (typeof result == "undefined") { if (Object.prototype.toString.call( item ) === "[object Array]") { result = []; item.forEach(function(child, index, array) { result[index] = clone( child ); }); } else if (typeof item == "object") { if (item.nodeType && typeof item.cloneNode == "function") { var result = item.cloneNode( true ); } else if (!item.prototype) { if (item instanceof Date) { result = new Date(item); } else { result = {}; for (var i in item) { result[i] = clone( item[i] ); } } } else { if (false && item.constructor) { result = new item.constructor(); } else { result = item; } } } else { result = item; } } return result; };
  exportValue = utils.exportValue;
  pair = utils.pair;
  subtestData = doc.subtestData;
  keyId = doc.assessmentId;
  if (doc.klassId != null) {
    keyId = doc.klassId;
    newData = clone(doc.subtestData);
    newData.subtestId = doc.subtestId;
    newData["variable_name"] = doc.itemType + "_" + doc.reportType + "_" + doc.part + "_";
    subtestData = [
      {
        data: newData,
        prototype: doc.prototype,
        subtestId: doc.subtestId
      }
    ];
  }

  /*
  Fix doubles (temporary)
   */
  doublesIncluded = clone(subtestData);
  subtestData = [];
  subtestIds = [];
  log("NEW");
  log(JSON.stringify(doublesIncluded));
  for (_i = 0, _len = doublesIncluded.length; _i < _len; _i++) {
    subtest = doublesIncluded[_i];
    log(subtest.subtestId + " " + subtestIds.indexOf(subtest.subtestId));
    if (subtestIds.indexOf(subtest.subtestId) === -1) {
      subtestData.push(subtest);
      subtestIds.push(subtest.subtestId);
    }
  }

  /*
  Handle universal fields
   */
  universal = [];
  universal.push(pair("enumerator", doc['enumerator']));
  universal.push(pair("start_time", doc['starttime'] || doc['start_time']));
  universal.push(pair("order_map", doc['order_map'] != null ? doc['order_map'].join(",") : "no_record"));
  bySubtest = [];
  bySubtest.push(pair("universal", universal));
  datetimeCount = 0;
  linearOrder = (function() {
    _results = [];
    for (var _j = 0, _ref = subtestData.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
    return _results;
  }).apply(this);
  orderMap = doc["order_map"] != null ? doc["order_map"] : doc["orderMap"] ? doc["orderMap"] : linearOrder;
  timestamps = [];
  for (_k = 0, _len1 = linearOrder.length; _k < _len1; _k++) {
    rawIndex = linearOrder[_k];
    row = [];
    subtestIndex = orderMap.indexOf(rawIndex);
    subtest = subtestData[subtestIndex];
    if (subtest == null) {
      log("skipped empty subtest");
      log(doc);
      continue;
    }
    if (subtest.data == null) {
      log("skipped subtest with null data");
      log(doc);
      continue;
    }
    prototype = subtest['prototype'];
    if (prototype === "id") {
      row.push(pair("id", subtest.data.participant_id));
    } else if (prototype === "location") {
      _ref1 = subtest.data.labels;
      for (i = _l = 0, _len2 = _ref1.length; _l < _len2; i = ++_l) {
        label = _ref1[i];
        row.push(pair(label, subtest.data.location[i]));
      }
    } else if (prototype === "datetime") {
      months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
      if (~months.indexOf(subtest.data.month.toLowerCase())) {
        monthData = months.indexOf(subtest.data.month.toLowerCase()) + 1;
      } else {
        monthData = subtest.data.month;
      }
      datetimeSuffix = datetimeCount > 0 ? "_" + datetimeCount : "";
      row.push(pair("year" + datetimeSuffix, subtest.data.year));
      row.push(pair("month" + datetimeSuffix, monthData));
      row.push(pair("date" + datetimeSuffix, subtest.data.day));
      row.push(pair("assess_time" + datetimeSuffix, subtest.data.time));
      datetimeCount++;
    } else if (prototype === "consent") {
      row.push(pair("consent", subtest.data.consent));
    } else if (prototype === "grid") {
      variableName = subtest.data.variable_name;
      row.push(pair("" + variableName + "_auto_stop", subtest.data.auto_stop));
      row.push(pair("" + variableName + "_time_remain", subtest.data.time_remain));
      row.push(pair("" + variableName + "_attempted", subtest.data.attempted));
      row.push(pair("" + variableName + "_item_at_time", subtest.data.item_at_time));
      row.push(pair("" + variableName + "_time_intermediate_captured", subtest.data.time_intermediate_captured));
      _ref2 = subtest.data.items;
      for (i = _m = 0, _len3 = _ref2.length; _m < _len3; i = ++_m) {
        item = _ref2[i];
        row.push(pair("" + variableName + (i + 1), exportValue(item.itemResult)));
      }
    } else if (prototype === "survey") {
      _ref3 = subtest.data;
      for (surveyVariable in _ref3) {
        surveyValue = _ref3[surveyVariable];
        if (surveyValue === Object(surveyValue)) {
          for (optionKey in surveyValue) {
            optionValue = surveyValue[optionKey];
            row.push(pair("" + surveyVariable + "_" + optionKey, exportValue(optionValue)));
          }
        } else {
          row.push(pair(surveyVariable, exportValue(surveyValue)));
        }
      }
    } else if (prototype === "observation") {
      _ref4 = subtest.data.surveys;
      for (i = _n = 0, _len4 = _ref4.length; _n < _len4; i = ++_n) {
        observations = _ref4[i];
        observationData = observations.data;
        for (surveyVariable in observationData) {
          surveyValue = observationData[surveyVariable];
          if (surveyValue === Object(surveyValue)) {
            for (optionKey in surveyValue) {
              optionValue = surveyValue[optionKey];
              row.push(pair("" + surveyVariable + "_" + optionKey + "_" + (i + 1), exportValue(optionValue)));
            }
          } else {
            row.push(pair("" + surveyVariable + "_" + (i + 1), exportValue(surveyValue)));
          }
        }
      }
    } else if (prototype === "gps") {
      row.push(pair("latitude", subtest.data.lat));
      row.push(pair("longitude", subtest.data.long));
      row.push(pair("accuracy", subtest.data.acc));
      row.push(pair("altitude", subtest.data.alt));
      row.push(pair("altitudeAccuracy", subtest.data.altAcc));
      row.push(pair("heading", subtest.data.heading));
      row.push(pair("speed", subtest.data.speed));
      row.push(pair("timestamp", subtest.data.timestamp));
    } else if (prototype === "complete") {
      row.push(pair("additional_comments", subtest.data.comment));
      row.push(pair("end_time", subtest.data.end_time));
    }
    timestamps.push(subtest.timestamp);
    bySubtest.push(pair(subtest.subtestId, row));
  }
  timestamps = timestamps.sort();
  bySubtest.push(pair("timestamps", [pair("timestamps", timestamps.join(','))]));
  return emit(keyId, bySubtest);
});
